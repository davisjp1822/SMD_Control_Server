\hypertarget{index_Introduction}{}\section{Introduction}\label{index_Introduction}
The goal of this software is to support all of the commands listed in the A\+M\+C\+I manual for the S\+M\+D series motors. Those commands are documented in the A\+M\+C\+I \href{http://www.amci.com/stepper-motor-control/integrated-stepper-motor-control-smd23e.asp}{\tt S\+M\+D user manual}.

If you haven\textquotesingle{}t already done so, you {\bfseries really} need to read R\+E\+A\+D\+M\+E.\+md in the root directory. Dependencies, limitations, and other important info are all contained in this file.

Comments, suggestions, bugs, etc. should all be directed to \href{jd@pauldavisautomation.com}{\tt jd@pauldavisautomation.\+com}\hypertarget{index_Commands}{}\section{Commands}\label{index_Commands}
All of these commands are used while connected to the server using {\ttfamily telnet} or some other terminal emulation program.

If you get unexplained errors, you may want to run S\+M\+D\+Server in verbose (debug) mode\+: {\ttfamily S\+M\+D\+Server -\/v}\hypertarget{index_connect}{}\subsection{connect}\label{index_connect}
Command format is as so (replace I\+P address with the S\+M\+D I\+P address)\+:

{\ttfamily connect,10.\+0.\+6.\+50}

If successful, server responds with {\ttfamily S\+M\+D\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_disconnect}{}\subsection{disconnect}\label{index_disconnect}
Command format is as follows (no I\+P address required)\+:

{\ttfamily disconnect}

No response is given by the server. The network light on the S\+M\+D should stop blinking at this time.\hypertarget{index_driveEnable}{}\subsection{drive\+Enable}\label{index_driveEnable}
Command format is as follows\+:

{\ttfamily drive\+Enable}

If successful, server responds with {\ttfamily E\+N\+A\+B\+L\+E\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_driveDisable}{}\subsection{drive\+Disable}\label{index_driveDisable}
Command format is as follows\+:

{\ttfamily drive\+Disable}

If successful, server responds with {\ttfamily D\+I\+S\+A\+B\+L\+E\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_jogCW}{}\subsection{jog\+C\+W}\label{index_jogCW}
Jogs the drive clockwise.

The format of the command is as follows\+:

{\ttfamily jog\+C\+W,accel,decel,jerk,speed}

The following limits apply\+: \begin{DoxyVerb}*accel* must be a positive integer between 1-5000

*decel* must be a postive integer between 1-5000

*jerk* must be a positive integer between 0-5000

*speed* must be a positive integer between configured starting speed (configured in AMCI NetConfigurator) and 2,999,999
\end{DoxyVerb}


If successful, server responds with {\ttfamily C\+O\+M\+M\+A\+N\+D\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_jogCCW}{}\subsection{jog\+C\+C\+W}\label{index_jogCCW}
Jogs the drive counter clockwise.

The format of the command is as follows\+:

{\ttfamily jog\+C\+C\+W,accel,decel,jerk,speed}

The following limits apply\+: \begin{DoxyVerb}*accel* must be a positive integer between 1-5000

*decel* must be a postive integer between 1-5000

*jerk* must be a positive integer between 0-5000

*speed* must be a positive integer between configured starting speed (configured in AMCI NetConfigurator) and 2,999,999
\end{DoxyVerb}


If successful, server responds with {\ttfamily C\+O\+M\+M\+A\+N\+D\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_relativeMove}{}\subsection{relative\+Move}\label{index_relativeMove}
Moves the motor a specified number steps, following a trapezoidal move profile. The motor does {\bfseries not} need to be homed.

The format of the command is as follows\+:

{\ttfamily relative\+Move,rel\+\_\+pos,accel,decel,jerk,speed}

The following limits apply\+: \begin{DoxyVerb}*rel_pos* must be an integer between -8,388,607 and +8,388,607

*accel* must be a positive integer between 1-5000

*decel* must be a postive integer between 1-5000

*jerk* must be a positive integer between 0-5000

*speed* must be a positive integer between configured starting speed (configured in AMCI NetConfigurator) and 2,999,999
\end{DoxyVerb}


If successful, server responds with {\ttfamily R\+E\+L\+\_\+\+M\+O\+V\+E\+\_\+\+C\+O\+M\+P\+L\+E\+T\+E}\hypertarget{index_holdMove}{}\subsection{hold\+Move}\label{index_holdMove}
Stops motion using the deceleration value specified in the active move profile. The drive will {\bfseries not} register a {\itshape Position Invalid} error.

The format of the command is as follows\+:

{\ttfamily hold\+Move}

If successful, server responds with {\ttfamily C\+O\+M\+M\+A\+N\+D\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_immedStop}{}\subsection{immed\+Stop}\label{index_immedStop}
Stops motion using a hard stop with no deceleration. The drive {\bfseries will} register a {\itshape Position Invalid} error and will need to be re-\/homed.

The format of the command is as follows\+:

{\ttfamily immed\+Stop}

If successful, server responds with {\ttfamily C\+O\+M\+M\+A\+N\+D\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_resetErrors}{}\subsection{reset\+Errors}\label{index_resetErrors}
Resets and errors in the drive that prevent motion. Depending on home state, some errors may persist. Consult A\+M\+C\+I manual for more details.

The format of this command is\+:

{\ttfamily reset\+Errors}

If successful, server responds with {\ttfamily R\+E\+S\+E\+T\+\_\+\+E\+R\+R\+O\+R\+S\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_readInputRegisters}{}\subsection{read\+Input\+Registers}\label{index_readInputRegisters}
Command to read input registers, outputs registers back to client in format 0x0, 0x0, 0, 0, 0, 0, 0, 0, 0, 0.

The format of the input registers follows the byte order as specified in the user manual section titled {\itshape Input Registers}. That is, the left most 0x0 above is word 0.

The format of this command is\+:

{\ttfamily read\+Input\+Registers}\hypertarget{index_presetMotorPosition}{}\subsection{preset\+Motor\+Position}\label{index_presetMotorPosition}
Command that presets the motor position (motor counts) to a specified value.

The format of the command is as follows\+:

{\ttfamily preset\+Motor\+Position,pos}

The following limits apply\+: \begin{DoxyVerb}*pos* must be an integer between -8,388,607 and +8,388,607
\end{DoxyVerb}


If successful, server responds with {\ttfamily P\+R\+E\+S\+E\+T\+\_\+\+P\+O\+S\+I\+T\+I\+O\+N\+\_\+\+S\+U\+C\+C\+E\+S\+S}\hypertarget{index_presetEncoderPosition}{}\subsection{preset\+Encoder\+Position}\label{index_presetEncoderPosition}
Command that presets the encoder position to a specified value.

The format of the command is as follows\+:

{\ttfamily preset\+Encoder\+Position,pos}

If successful, server responds with {\ttfamily P\+R\+E\+S\+E\+T\+\_\+\+E\+N\+C\+O\+D\+E\+R\+\_\+\+S\+U\+C\+C\+E\+S\+S}

The following limits apply\+: \begin{DoxyVerb}*pos* must be an integer between -8,388,607 and +8,388,607
\end{DoxyVerb}
\hypertarget{index_Configuration}{}\subsection{(load\+Current\+Configuration, read\+Current\+Configuration, save\+Config)}\label{index_Configuration}
Configuration is a bit of a tricky item with these drives. You really need to read the user manual and understand how the drive interprets the \char`\"{}configuration mode\char`\"{} bit in the Command Word or else you are going to run into problems with annoying errors and the like. Also, you will want to learn the difference between writing the configuration to the onboard flash versus just loading it into memory.

When wrapping a G\+U\+I around this process, you will have to make sure to give the drive ample time to flip bits and process the information.

In general though, the operation goes something like this (in order of operations from the client to the server)\+:


\begin{DoxyEnumerate}
\item Execute {\ttfamily load\+Current\+Configuration} to put the drive into Configuration Mode and load the input registers with the current configuration.
\item Execute {\ttfamily read\+Current\+Configuration} which will echo the current configuration to the client terminal using a similar format as the input (status) registers.
\item Optionally, use save\+Config to send a configuration back to the S\+M\+D.
\item To put the drive back into Command Mode, use {\ttfamily reset\+Errors} or {\ttfamily drive\+Enable} to flip the appropriate bits.
\end{DoxyEnumerate}\hypertarget{index_loadCurrentConfiguration}{}\subsection{load\+Current\+Configuration}\label{index_loadCurrentConfiguration}
See above for explanation.

The format of the command is as follows\+:

{\ttfamily load\+Current\+Configuration}

If successful, server responds with {\ttfamily R\+E\+A\+D\+Y\+\_\+\+T\+O\+\_\+\+R\+E\+A\+D\+\_\+\+C\+O\+N\+F\+I\+G}\hypertarget{index_readCurrentConfiguration}{}\subsection{read\+Current\+Configuration}\label{index_readCurrentConfiguration}
See above (point 2) for explanation. The return format of the config input registers is as follows\+:

{\ttfamily \#\#\#0x0,0x0,0,0,0,0,0,0,0,0}

Similar to the status input registers, this format is in the same order as the registers in the user manual (the leftmost word is Config Word 0)\hypertarget{index_saveConfig}{}\subsection{save\+Config}\label{index_saveConfig}
Saves a configuration specified by the following command string to the drive\+:

{\ttfamily save\+Config,control\+\_\+word,config\+\_\+word,motor\+\_\+starting\+\_\+speed,motor\+\_\+steps\+\_\+per\+\_\+turn,encoder\+\_\+pulses\+\_\+per\+\_\+turn,idle\+\_\+current\+\_\+percentage,motor\+\_\+current} \begin{DoxyVerb}*control_word* is a decimal representation of the Control Word as outlined in the SMD user manual
*config_word* is a decimal representation of the Config Word as outlined in the SMD user manual
*motor_starting_speed is a positive integer between 1 and 1999999
*motor_steps_per_turn* is a positive integer between 200 and 32767
*encoder_pulses_per_turn* is 1024
*idle_current_percentage* is an integer between 1 and 100, representing 1% of total motor current to 100% of 3.4A.
*motor_current* is a value between 1 and 34, representing 1.0A to 3.4A
\end{DoxyVerb}
\hypertarget{index_homeCW}{}\subsection{home\+C\+W}\label{index_homeCW}
Executes a predefined homing routine where the motor jogs clockwise at the specified speed until seeing the Home Limit input close.

The format of the command is as follows\+:

{\ttfamily home\+C\+W,speed,accel,decel,jerk} \begin{DoxyVerb}*speed* is an integer between 1 and 2999999
*accel* is an integer between 1 and 5000
*decel* is an integer between 1 and 5000
*jerk* is an integer between 1 and 5000
\end{DoxyVerb}
\hypertarget{index_homeCCW}{}\subsection{home\+C\+C\+W}\label{index_homeCCW}
Executes a predefined homing routine where the motor jogs counter clockwise at the specified speed until seeing the Home Limit input close.

The format of the command is as follows\+:

{\ttfamily home\+C\+C\+W,speed,accel,decel,jerk} \begin{DoxyVerb}*speed* is an integer between 1 and 2999999
*accel* is an integer between 1 and 5000
*decel* is an integer between 1 and 5000
*jerk* is an integer between 1 and 5000
\end{DoxyVerb}
\hypertarget{index_programAssembledMove}{}\subsection{program\+Assembled\+Move}\label{index_programAssembledMove}
You will definitely want to home the motor prior to trying an assembled move.

Once homed, you upload the move profile to the drive using the following command\+:

{\ttfamily program\+Assembled\+Move,move\+\_\+json}

{\itshape move\+\_\+json} is a J\+S\+O\+N string with the following format\+: \begin{DoxyVerb}{

    "segment": {
        "target_pos_inches": 5200,
        "programmed_speed": 1000,
        "accel": 150,
        "decel": 150,
        "jerk": 0
    },
    "segment": {
        "target_pos_inches": 5200,
        "programmed_speed": 2000,
        "accel": 150,
        "decel": 150,
        "jerk": 0
    },
    "segment": {
        "target_pos_inches": 5200,
        "programmed_speed": 4000,
        "accel": 150,
        "decel": 150,
        "jerk": 0
    }
}
\end{DoxyVerb}


An assembled move profile can have up to {\bfseries 16} segments.

It does take some time for the move to program, so be patient. Each move segment takes $\sim$2 seconds.

When the profile is successfully accepted, the server responds with {\ttfamily A\+S\+S\+E\+M\+B\+L\+E\+D\+\_\+\+M\+O\+V\+E\+\_\+\+A\+C\+C\+E\+P\+T\+E\+D} to the client.\hypertarget{index_runAssembledDwellMove}{}\subsection{run\+Assembled\+Dwell\+Move}\label{index_runAssembledDwellMove}
Once a move profile is loaded using {\ttfamily program\+Assembled\+Move}, it can be executed with either {\ttfamily run\+Assembled\+Dwell\+Move} or {\ttfamily run\+Assembled\+Blend\+Move}.

If the motor {\bfseries changes direction}, you {\bfseries M\+U\+S\+T} use a dwell move! The dwell allows the motor to decel and then change directions.

This format for this command is {\ttfamily run\+Assembled\+Dwell\+Move,dwell\+\_\+time}. \begin{DoxyVerb}*dwell_time* is the time, in milliseconds (ms) that the drive should wait between move segments
\end{DoxyVerb}
\hypertarget{index_runAssembledBlendMove}{}\subsection{run\+Assembled\+Blend\+Move}\label{index_runAssembledBlendMove}
Once a move profile is loaded using {\ttfamily program\+Assembled\+Move}, it can be executed with either {\ttfamily run\+Assembled\+Dwell\+Move} or {\ttfamily run\+Assembled\+Blend\+Move}.

If the motor {\bfseries changes direction}, you {\bfseries M\+U\+S\+T} use a dwell move! The dwell allows the motor to decel and then change directions. There is no delay between segments in a blend move.

This format for this command is {\ttfamily run\+Assembled\+Blend\+Move,direction}. \begin{DoxyVerb}*direction* is the motor rotation direction - 0 is CW, 1, CCW
\end{DoxyVerb}
\hypertarget{index_startManualMode}{}\subsection{start\+Manual\+Mode}\label{index_startManualMode}
Used to enable manual control mode. Beta, and undocumented. If you want to do analog control over the network, you are good enough to read the source. I originally used this as a demo using an Arduino Yun. Check out the Arduino file in this repository for an idea of what is going on. Then, read the C source.\hypertarget{index_stopManualMode}{}\subsection{stop\+Manual\+Mode}\label{index_stopManualMode}
See above. There be dragons here. 